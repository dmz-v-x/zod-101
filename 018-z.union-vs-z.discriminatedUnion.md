## `z.union` vs `z.discriminatedUnion`

### Step 1 — The Real-World Problem: Variant Data Shapes

In real applications, data does not always follow a single shape.

Common examples:

- Login method → email **OR** phone
- Event type → LOGIN **OR** LOGOUT
- Payment method → CARD **OR** UPI **OR** PAYPAL
- API response → SUCCESS **OR** ERROR

Trying to force all of these into one object shape leads to:
- Optional-field explosions
- Fragile condition checks
- Poor TypeScript narrowing

Zod provides **union schemas** to model these cases correctly.

---

### Step 2 — `z.union()`

#### What `z.union()` Means

> “The value must match **one of** the provided schemas.”

#### Basic Example

	const idSchema = z.union([
	  z.string().uuid(),
	  z.number().int().positive(),
	]);

Valid:

	"550e8400-e29b-41d4-a716-446655440000"
	123

Invalid:

	true
	"not-id"

---

#### Object Union Example

	const emailLogin = z.object({
	  email: z.string().email(),
	  password: z.string(),
	});

	const phoneLogin = z.object({
	  phone: z.string(),
	  otp: z.string(),
	});

	const loginSchema = z.union([emailLogin, phoneLogin]);

This is valid Zod code — but it has downsides for production.

---

### Step 3 — Why Plain `z.union()` Becomes Painful

#### Problem 1 — Ambiguous Errors

	loginSchema.safeParse({ email: "x" });

Zod behavior:
- Tries schema A → fails
- Tries schema B → fails
- Combines errors from both

Result:
- No clear indication of the intended variant
- Harder error messages for clients

---

#### Problem 2 — Harder TypeScript Narrowing

TypeScript sees:

	{
	  email: string;
	  password: string;
	} | {
	  phone: string;
	  otp: string;
	}

You must manually check fields to narrow the type.

---

#### Problem 3 — Performance

- Zod must try **every schema** until one passes
- Large unions can become expensive

---

### Step 4 — `z.discriminatedUnion()`

#### Core Idea

Use a **shared discriminator field** to decide which variant applies.

Common discriminator fields:

- `type`
- `kind`
- `method`
- `status`

Zod reads the discriminator value and **validates only the matching schema**.

---

### Step 5 — Basic Discriminated Union Example

	const loginSchema = z.discriminatedUnion("method", [
	  z.object({
	    method: z.literal("email"),
	    email: z.string().email(),
	    password: z.string(),
	  }),
	  z.object({
	    method: z.literal("phone"),
	    phone: z.string(),
	    otp: z.string(),
	  }),
	]);

What Zod does:

1. Reads `method`
2. Selects the matching schema
3. Validates only that schema

Benefits:

- Faster validation
- Cleaner errors
- Stronger TypeScript inference

---

### Step 6 — TypeScript Narrowing

	type Login = z.infer<typeof loginSchema>;

Now TypeScript understands the variants:

	if (login.method === "email") {
	  login.email;    // ✅
	  login.password; // ✅
	}

No casting. No hacks.

---

### Step 7 — Real-World Example: API Responses

	const successResponse = z.object({
	  status: z.literal("success"),
	  data: z.object({
	    id: z.string(),
	  }),
	});

	const errorResponse = z.object({
	  status: z.literal("error"),
	  message: z.string(),
	});

	const responseSchema = z.discriminatedUnion("status", [
	  successResponse,
	  errorResponse,
	]);

Client-side code becomes clean:

	if (res.status === "success") {
	  res.data.id;
	} else {
	  res.message;
	}

---

### Step 8 — Event System Example

	const eventSchema = z.discriminatedUnion("type", [
	  z.object({
	    type: z.literal("LOGIN"),
	    userId: z.string(),
	  }),
	  z.object({
	    type: z.literal("LOGOUT"),
	    userId: z.string(),
	  }),
	]);

Perfect for:
- Analytics pipelines
- Event queues
- Logging systems

---

### Step 9 — When to Use Which

| Situation | Use |
|--------|-----|
| Simple OR types | `z.union()` |
| Object variants | `z.discriminatedUnion()` |
| Performance-sensitive validation | `z.discriminatedUnion()` |
| Clean TypeScript narrowing | `z.discriminatedUnion()` |

---

### Step 10 — Common Production Mistakes

#### ❌ Mistake 1 — Using `z.union()` for Object Variants

	z.union([objA, objB]); // ❌ avoid when possible

Prefer discriminated unions for objects.

---

#### ❌ Mistake 2 — Inconsistent Discriminator Values

	method: "Email" // ❌

Discriminator values must be:
- Exact literals
- Consistent across variants
- Unique per variant

---

#### ❌ Mistake 3 — Forgetting About Extra Keys

- `z.discriminatedUnion()` follows `z.object()` defaults
- Extra keys are allowed unless restricted

For security-sensitive APIs, consider:

	.strict()

---

### Golden Rule 

**If variants share a common field → use `z.discriminatedUnion()`**

It produces:
- Cleaner validation
- Better errors
- Faster performance
- Superior TypeScript inference
