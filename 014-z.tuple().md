## `z.tuple`

### Step 1 — Why Arrays Are Sometimes Not Enough

Arrays answer one basic question:

> “Is this a list of values of the same type?”

Example:

	z.array(z.number())

This only guarantees:
- The value is a list
- Every item is a number

But sometimes you need something stricter:

> “Is this a **fixed number of values**, in a **fixed order**, where **each position has a different meaning**?”

Example:

	[latitude, longitude]

Both values are numbers, but:
- Order matters
- Meaning is positional

Arrays cannot express this clearly or safely.

---

### Step 2 — What a Tuple Actually Is

A **tuple** in Zod is:

- Fixed length
- Fixed order
- Each position has its **own schema**

Think of a tuple as:

	[number, number]

But with **semantic meaning attached to each index**.

This is exactly what `z.tuple()` is designed for.

---

### Step 3 — `z.tuple()` Basic Usage

	const pointSchema = z.tuple([
	  z.number(),
	  z.number(),
	]);

Valid:

	[10, 20]

Invalid:

	[10]          // ❌ too short
	[10, 20, 30]  // ❌ too long
	["10", 20]    // ❌ wrong type at index 0

Zod enforces:
- Exact length
- Exact order
- Exact type per position

---

### Step 4 — Tuple Error Reporting

When tuple validation fails, Zod reports **index-level errors**.

Example:

	pointSchema.parse(["10", 20]);

ZodError issues conceptually include:

	path: [0]
	message: "Expected number, received string"

This makes tuple validation very debuggable:
- You know **which position failed**
- You know **why it failed**

This behavior is documented in Zod’s error system.

---

### Step 5 — TypeScript Inference

	type Point = z.infer<typeof pointSchema>;

Resulting type:

	type Point = [number, number];

This is **not** the same as:

	number[]

Key difference:

- `number[]` → any length
- `[number, number]` → exactly two numbers, fixed order

Zod and TypeScript stay perfectly aligned.

---

### Step 6 — Real-World Examples

#### A) Geographic Coordinates

	const coordinatesSchema = z.tuple([
	  z.number().min(-90).max(90),     // latitude
	  z.number().min(-180).max(180),   // longitude
	]);

This prevents:
- Invalid latitude/longitude
- Missing values
- Extra values
- Swapped semantics

---

#### B) Key–Value Pairs

	const entrySchema = z.tuple([
	  z.string(),
	  z.number(),
	]);

Example:

	["apples", 5]

This clearly communicates:
- Index 0 → key
- Index 1 → value

---

#### C) Date Ranges

	const dateRangeSchema = z.tuple([
	  z.date(),
	  z.date(),
	]);

Represents:

	[startDate, endDate]

At this stage, Zod ensures:
- Exactly two dates
- Correct order and types

---

### Step 7 — Refining Tuples

Sometimes validation depends on **multiple tuple values together**.

Example: start date must be before end date.

	const dateRangeSchema = z
	  .tuple([z.date(), z.date()])
	  .refine(
	    ([start, end]) => start < end,
	    { message: "Start date must be before end date" }
	  );

This is **official Zod behavior**:
- Base tuple validates structure
- `.refine()` validates relationships between positions

---

### Step 8 — Tuples Inside Objects

Tuples are commonly nested inside objects.

	const locationSchema = z.object({
	  name: z.string(),
	  coordinates: z.tuple([
	    z.number(),
	    z.number(),
	  ]),
	});

This pattern is common in:
- Geo APIs
- Mapping services
- Analytics payloads

Nested tuple validation works automatically.

---

### Step 9 — Common Production Mistakes

#### ❌ Mistake 1 — Using Array Instead of Tuple

	z.array(z.number()); // ❌ allows [1, 2, 3]

If you expect **exactly two values**, use a tuple.

---

#### ❌ Mistake 2 — Using Tuples for Dynamic Data

Tuples are **not** for:
- Lists
- Collections
- Variable-length data

If length can change → use `z.array()`.

---

#### ❌ Mistake 3 — Forgetting Semantic Meaning

Tuples rely on **convention**.

Always document what each position represents:

	[latitude, longitude]
	[startDate, endDate]

Without meaning, tuples become confusing and error-prone.

---

### Step 10 — When NOT to Use Tuples

Do **not** use tuples when:

- Number of items can change
- Order does not matter
- Items are homogeneous

In those cases, arrays are the correct tool.

---

### Golden Rule 

**Arrays** → many items of the same kind  
**Tuples** → few items, fixed order, different meanings  

Use tuples when structure matters — and your schemas will be precise, expressive, and safe.
