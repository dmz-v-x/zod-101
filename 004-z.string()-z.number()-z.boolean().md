### 1. What Is a *Primitive Schema*?

In Zod, a **schema** is a runtime validator â€” a rule that checks whether a value matches some shape or type.  
A **primitive schema** specifically validates **a single value**, not an object.  
Primitive schemas are the simplest building blocks you can use to define more complex structures.

Think of them as:

> **â€œRules for one single value.â€**

Examples of primitive schemas in Zod:

- `z.string()` â†’ a string  
- `z.number()` â†’ a number  
- `z.boolean()` â†’ a boolean

These are foundational â€” everything else (objects, arrays, etc.) is built from these.

---

### 2. Importing Zod

To use Zod, you import its main namespace:

	import { z } from "zod";

What does this mean?

- `z` is where all validation methods live
- Every schema starts with `z.` (e.g., `z.string()`, `z.number()`, `z.object()`)

This tells the runtime to load Zod from your project dependencies so you can define schemas. :contentReference[oaicite:2]{index=2}

Example:

	import { z } from "zod";

	const userSchema = z.object({
	  name: z.string(),
	  age: z.number().min(18),
	});

	const user = { name: "Alice", age: 20 };

	userSchema.parse(user);

Here:

- `z.object({...})` creates an object schema  
- `z.string()` and `z.number()` define primitive rules  
- `.parse()` validates the data against the schema 

---

### 3. `z.string()` â€” The Simplest Schema

To define a rule that only accepts strings:

	import { z } from "zod";

	const nameSchema = z.string();

This schema means:

- The value must exist  
- The value must be a string  
- Nothing else is allowed 

Try parsing:

	nameSchema.parse("Himanshu"); // âœ… OK
	nameSchema.parse(123);       // âŒ throws
	nameSchema.parse(null);      // âŒ throws

Zod performs this check **at runtime**, so your app is protected from unexpected values. 

---

### 4. Real-World Example: User Input

Imagine a signup form:

	const usernameSchema = z.string();

Incoming values might be:

- `"Himanshu"` â†’ âœ… valid  
- `""` â†’ âœ… (empty string *is still a string*)  
- `123` â†’ âŒ  
- `undefined` â†’ âŒ

âš ï¸ Important  
Zod does **not guess intent** â€” it literally checks types.  
An empty string is still a string unless you add a rule saying otherwise.

---

### 5. `z.number()`

	import { z } from "zod";
	const ageSchema = z.number();

This checks that the value is:

- A number  
- Not a string  
- Not `NaN`  
- Not `"20"` 

Try:

	ageSchema.parse(20);     // âœ…
	ageSchema.parse("20");   // âŒ
	ageSchema.parse(NaN);    // âŒ

---

### 6. Real-World Gotcha (VERY IMPORTANT)

HTTP requests and form inputs often send numeric values as strings:

	{ "age": "20" }

âŒ `z.number()` will reject this â€” and thatâ€™s intentional.  
Zod is **strict by default**. 

Later, you can learn ways to *coerce* strings into numbers explicitly (e.g., `z.coerce.number()`), but stricter validation is safer by default.

---

### 7. `z.boolean()`

	import { z } from "zod";
	const isAdminSchema = z.boolean();

Valid values:

- `true` â†’ âœ…  
- `false` â†’ âœ…

Invalid values:

- `"true"` â†’ âŒ  
- `1` â†’ âŒ  
- `0` â†’ âŒ  
- `null` â†’ âŒ 

Zod does not guess â€” it demands exactly the right type.

---

### 8. `parse()` vs `safeParse()` (Intro)

In general, â€œparseâ€ means:

> Take input, check it, and either return validated data or signal that itâ€™s wrong.

Zod gives you two ways to do this: `.parse()` and `.safeParse()`. 

---

### 9. What `.parse()` Means in Zod

When you write:

	z.string().parse(value)

It means:

- Check if `value` is a string  
- If yes â†’ return it  
- If no â†’ **throw an error immediately** 

It *never* returns gracefully â€” it throws.

---

### 10. Breaking Down This Line

	z.string().parse(123);

Step by step:

- `z.string()` â†’ creates a string-only rule  
- `.parse(123)` â†’ tries to validate `123`

Since `123` is not a string, Zod throws a `ZodError`. 

---

### 11. What â€œThrows on Errorâ€ Actually Means

When a function **throws**:

- The program stops executing at that point  
- Unless you catch the error, your app crashes

Example:

	z.string().parse(123);
	console.log("This will NEVER run");

Because the error interrupts execution.

---

### 12. Why Crash on Invalid Data?

Crashing on invalid data may seem harsh, but it enforces correctness:

- Invalid data is a bug
- Failing fast avoids bad state
- Bugs become obvious early

This approach is intentional in Zod.

---

### 13. When Using `.parse()` Is the Right Choice

Use `.parse()` when **invalid data should never happen**:

Example â€” environment variables:

	const PORT = z.number().parse(process.env.PORT);

If PORT is missing or wrong â†’ crash ğŸ’¥  
Thatâ€™s correct for config you *must* have.

Other good times:

- Internal config files  
- Server startup  
- Developer-generated data

---

### 14. When `.parse()` Is a BAD Idea

âŒ Donâ€™t use `.parse()` when data comes from:

- Users  
- Forms  
- API requests

People make mistakes â€” your app should handle them gracefully.

---

### 15. The Biggest Gotcha âš ï¸

`.parse()` does **not** return an error object.

You might think:

	const result = z.string().parse(123);

But no â€” it either returns valid value *or throws*.  
Thereâ€™s no `result` on failure unless you wrap it in `try/catch`.

Example:

	try {
	  const value = z.string().parse(123);
	} catch (err) {
	  console.log("Invalid input");
	}

---

### 16. Why Zod Chose This Design

Zod gives you two philosophies:

| Method        | Behavior                |
| ------------- | ----------------------- |
| `parse()`     | Throws on invalid data  |
| `safeParse()` | Returns an object       |

This gives you flexibility: strict + crash or safe + handle errors. 

---

### 17. Mental Model (Important)

Think of `.parse()` like:

> **â€œI am absolutely sure this must be correct. If not, stop everything.â€**

Itâ€™s not meant for ordinary user input.

---

### 18. Simple Analogy

- `.parse()` is like rocket launch checks â€” abort immediately on error ğŸš¨  
- `.safeParse()` is like form validation â€” show errors and continue ğŸ™‚

---

### 19. Summary of `.parse()`

- Validates input  
- Throws on invalid data  
- Crashes on purpose  
- Not for user input  

---

### 20. `.safeParse()` â€” Never Throws

With `.safeParse()`:

	const result = z.string().safeParse(123);

	if (!result.success) {
	  console.log(result.error);
	}

This returns a result object instead of throwing, so you can handle failures gracefully. 

---

### 21. Mini Real-World Example

Validate a login payload:

	const loginSchema = z.object({
	  email: z.string(),
	  password: z.string(),
	  rememberMe: z.boolean(),
	});

	const body = {
	  email: "test@example.com",
	  password: "secret",
	  rememberMe: true,
	};

	const result = loginSchema.safeParse(body);

	if (!result.success) {
	  // return 400
	}

	const data = result.data;
	// data.email â†’ string
	// data.password â†’ string
	// data.rememberMe â†’ boolean

This prevents crashes and enforces type safety.

---

### 22. What Primitives *Do Not* Do

Primitive schemas **do not**:

- Trim strings  
- Check email format  
- Enforce min/max limits  
- Coerce types automatically

Those are additional rules you must add explicitly when needed.
