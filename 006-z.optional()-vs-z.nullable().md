## `z.optional()` vs `z.nullable()`

### 1. First Fix the Mental Model

JavaScript has **two different “absence” values**:

| Value        | Meaning                          |
|--------------|----------------------------------|
| `undefined`  | Value is **missing**             |
| `null`       | Value is **intentionally empty** |

They are **not the same**, and Zod models this distinction **explicitly**.

This mental model is fully aligned with the latest Zod documentation.

---

### 2. Where `undefined` Comes From

`undefined` appears when a value is **not provided at all**.

Common cases:

- Property is not sent in a request
- Form field is omitted
- Optional query parameter is missing
- PATCH request with partial updates

Example request body:

	{ "email": "a@b.com" }

Here:

	req.body.age === undefined

This is a **missing value**, not an empty one.

---

### 3. Where `null` Comes From

`null` is usually **explicitly sent** to mean “clear this value”.

Common cases:

- Sent intentionally by the client
- Stored in databases
- Used to remove/reset a field

Example request body:

	{ "age": null }

This is a **deliberate signal**, not an omission.

---

### 4. `z.optional()` — Property May Be Missing

Basic usage:

	const schema = z.object({
	  nickname: z.string().optional(),
	});

Valid:

	{}                     // ✅ missing
	{ nickname: "Sam" }    // ✅ present

Invalid:

	{ nickname: null }     // ❌

Meaning:

> “This field **may not exist at all**, but if it exists, it must be a string.”

This behavior matches the latest Zod docs exactly.

---

### 5. `z.nullable()` — Property Exists but May Be `null`

Basic usage:

	const schema = z.object({
	  middleName: z.string().nullable(),
	});

Valid:

	{ middleName: "Lee" }  // ✅
	{ middleName: null }   // ✅

Invalid:

	{}                     // ❌ missing

Meaning:

> “This field **must exist**, but it may be null.”

Again, this is exactly how Zod defines `nullable`.

---

### 6. Combining Both (VERY COMMON)

You can combine them:

	const schema = z.object({
	  bio: z.string().nullable().optional(),
	});

Valid:

	{}                    // ✅ missing
	{ bio: null }         // ✅ explicitly empty
	{ bio: "Hello" }      // ✅ present value

Use this pattern when:

- Frontend may omit the field
- Backend may store `null`
- PATCH endpoints with partial updates

This is a **documented and recommended** Zod pattern.

---

### 7. TypeScript Inference (Accurate Modeling)

	type User = z.infer<typeof schema>;

Resulting TypeScript type:

	{
	  bio?: string | null;
	}

Zod correctly reflects **real runtime possibilities** in TypeScript.

This aligns perfectly with Zod’s design goals.

---

### 8. Real-World API Scenarios

#### Scenario A — Signup (Required Field)

	const schema = z.object({
	  email: z.string(),
	});

- User **must** send `email`
- Missing value → validation fails

---

#### Scenario B — Profile Update (PATCH)

	const schema = z.object({
	  displayName: z.string().optional(),
	  bio: z.string().nullable().optional(),
	});

Client can:

- Update fields
- Clear fields (`null`)
- Leave fields untouched (`undefined`)

This is the **correct Zod approach** for PATCH APIs.

---

### 9. Common Mistakes (Cause Real Bugs)

#### Mistake 1 — Using `optional` Instead of `nullable`

	z.string().optional(); // ❌ does NOT allow null

Frontend sends:

	{ "bio": null }

➡️ Validation fails unexpectedly.

Correct version:

	z.string().nullable().optional();

---

#### Mistake 2 — Treating `null` and `undefined` the Same

	if (!user.bio) { ... }  // ❌ dangerous

This breaks when:

- `bio = ""` (empty string)
- `bio = null`
- `bio = undefined`

Correct check:

	if (user.bio == null) {
	  // handles null OR undefined explicitly
	}

---

### 10. Express Example (Corrected & Doc-Aligned)

	const updateProfileSchema = z.object({
	  displayName: z.string().min(1).optional(),
	  bio: z.string().max(200).nullable().optional(),
	});

	app.patch("/", (req, res) => {
	  const result = updateProfileSchema.safeParse(req.body);

	  if (!result.success) {
	    return res.status(400).json({ error: "Invalid input" });
	  }

	  const data = result.data;
	  // data.displayName?: string
	  // data.bio?: string | null

	  res.send("ok");
	});

This handles **all cases correctly** and follows Zod best practices.

---

### Golden Rule (Memorize This)

- `optional` → **may be missing**
- `nullable` → **may be null**

They solve **different problems**  
Zod models them **explicitly and correctly**

---

### Final Takeaway

- `undefined` ≠ `null`
- Zod treats them differently on purpose
- Use `optional()` and `nullable()` intentionally
- Correct schemas prevent subtle production bugs

