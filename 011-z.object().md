## `z.object()`

### 1. What `z.object()` Actually Is

`z.object()` defines a schema for a JavaScript object.

It specifies:

- A **shape**
- With keys
- Each key has its own Zod schema

Think of it as:

> **“A contract for an object’s structure.”**

When you validate data against a `z.object()`, Zod ensures the runtime value matches the expected shape. 

---

### 2. Smallest Possible Object Schema

	import { z } from "zod";

	const schema = z.object({});

This means:

- The value must be an object  
- But it can be **empty**

Valid:

	{}

Invalid:

	null  
	"hello"  
	[]  

By default, Zod expects an object here — anything else fails. 

---

### 3. Required Properties (Default Behavior)

Unless you explicitly make a property optional, it is required:

	const userSchema = z.object({
	  email: z.string(),
	  age: z.number(),
	});

Valid:

	{ email: "a@b.com", age: 20 }

Invalid:

	{ email: "a@b.com" }      // ❌ age missing  
	{ age: 20 }               // ❌ email missing

This is how most APIs and DTOs behave. 

---

### 4. What Happens When a Key Is Missing

If a required key is missing, Zod will produce a validation error:

	userSchema.safeParse({ email: "a@b.com" });

Conceptually:

	age: "Required"

Zod distinguishes between:

- **Missing property**
- **Wrong type**

Both are validation failures. 

---

### 5. Optional Properties Inside Objects

You can make some keys optional:

	const userSchema = z.object({
	  email: z.string(),
	  nickname: z.string().optional(),
	});

Valid:

	{ email: "a@b.com" }  
	{ email: "a@b.com", nickname: "Sam" }

Invalid:

	{ nickname: "Sam" } // ❌ email missing

Optional properties allow more flexible input without losing type safety. 

---

### 6. Extra Keys (VERY IMPORTANT DEFAULT)

**Updated Behavior (official docs):**  
By default, Zod object schemas **strip out unknown keys during parsing**.

Example:

	const schema = z.object({
	  email: z.string(),
	});

	z.safeParse({
	  email: "a@b.com",
	  role: "admin",
	  hacked: true,
	});

➡️ Result:

	{ email: "a@b.com" }

The extra keys are **removed**, not kept. 

This default *strip* behavior helps keep your output clean and matches the defined object shape.

---

### 7. `.strict()` — Lock Down Objects

If you want to **disallow extra keys entirely**, use `.strict()`:

	const schema = z
	  .object({
	    email: z.string(),
	  })
	  .strict();

Now this fails:

	{
	  email: "a@b.com",
	  role: "admin"
	}

Use `.strict()` when:

- Security matters
- You want strict API contracts
- Extra fields should be treated as errors instead of ignored

This behavior is documented in Zod docs. 

---

### 8. `.passthrough()` and `.strip()`

You can explicitly choose how extra keys are handled:

- **`.passthrough()` → keep unknown keys**  
- **`.strip()` → remove unknown keys (same as default)**

Example:

	schema.passthrough().parse({
	  email: "a@b.com",
	  role: "admin",
	});

➡️ Result:

	{ email: "a@b.com", role: "admin" }

These helper methods let you customize object behavior. 

---

### 9. Nested Objects

Most real-world payloads are nested.

Example: address inside user

	const addressSchema = z.object({
	  street: z.string(),
	  city: z.string(),
	});

	const userSchema = z.object({
	  email: z.string().email(),
	  address: addressSchema,
	});

Valid:

	{
	  email: "a@b.com",
	  address: { street: "Main St", city: "NY" },
	}

Invalid:

	{
	  email: "a@b.com",
	  address: { street: "Main St" },
	}

Nested validation is automatic — Zod runs validation deeply. 

---

### 10. Example: Real API Schema

Signup payload:

	const signupSchema = z.object({
	  email: z.string().email(),
	  password: z.string().min(8),
	  profile: z.object({
	    displayName: z.string().min(1),
	    bio: z.string().nullable().optional(),
	  }),
	})

This schema:

- Validates deeply
- Rejects partial nested data
- Produces safe and clean output

You get thorough validation for complex shapes. 

---

### 11. TypeScript Inference 

You can derive TypeScript types from your schema:

	type SignupInput = z.infer<typeof signupSchema>;

The resulting type exactly matches the validated shape — no duplication, no mismatch. 

---

### 12. Common Production Mistakes

❌ **Forgetting `.strict()` for sensitive APIs**  
Extra fields may get silently stripped, hiding potential issues.

❌ **Validating only top-level object**  
	z.object({ profile: z.any() }); // ❌ loses safety

You lose nested safety if you use `z.any()` too broadly.

❌ **Re-validating inside services**  
Validate once at the boundary — do not scatter validation code throughout business logic.

These anti-patterns undermine the guarantees Zod provides.

---

### 13. Golden Rule

> **Objects define trust boundaries.**  
> Validate them carefully.

When you define a `z.object()`, you’re formalizing what your application *trusts* as valid data. Zod helps you enforce that contract reliably and predictably. 
