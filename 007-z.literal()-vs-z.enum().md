## `z.literal()` vs `z.enum()`

### 1. The Real Problem These Schemas Solve

In real applications, some fields must be **specific, known values**.

Examples:

- user role → `"user"` | `"admin"`
- status → `"pending"` | `"active"` | `"blocked"`
- feature flag → `"on"` | `"off"`
- event type → `"LOGIN"` | `"LOGOUT"`

Without runtime validation, this can happen:

	{ "role": "superadmin" }

The application may:
- accept invalid data
- behave incorrectly
- fail silently later

Zod exists to **prevent invalid values at runtime**.

---

### 2. `z.literal()` — Exact Value Only

`z.literal()` means:

> “This value must be **exactly** this one value.”

Basic example:

	import { z } from "zod";

	const activeSchema = z.literal("active");

Valid:

	"active" // ✅

Invalid:

	"ACTIVE"   // ❌
	"pending"  // ❌

`z.literal()` is strict and case-sensitive by design.

---

### 3. Real-World Use Case: Fixed Flags

Example: protocol or event marker

	import { z } from "zod";

	const schema = z.object({
	  type: z.literal("LOGIN"),
	});

Only `"LOGIN"` is allowed.

Common use cases:

- discriminator fields
- protocol markers
- version flags
- internal event identifiers

This aligns exactly with the official Zod docs.

---

### 4. `z.enum()` — Set of Allowed Strings

When a field can be **one of many known values**, use `z.enum()`.

Basic usage (doc-aligned):

	import { z } from "zod";

	const roleSchema = z.enum(["user", "admin"] as const);

Valid:

	"user"   // ✅
	"admin"  // ✅

Invalid:

	"superadmin" // ❌

Important (from Zod docs):

- `z.enum()` expects a **tuple of strings**
- Using `as const` ensures this at compile time

---

### 5. TypeScript Inference (Key Benefit)

	type Role = z.infer<typeof roleSchema>;

Resulting type:

	type Role = "user" | "admin";

You get:

- Runtime validation ✅
- Compile-time union type ✅
- Zero duplication

This is a core Zod feature.

---

### 6. Real-World Example: User Role Validation

	import { z } from "zod";

	const userSchema = z.object({
	  email: z.email(),              // latest Zod docs
	  role: z.enum(["user", "admin"] as const),
	});

Incoming request:

	{ "email": "a@b.com", "role": "admin" }

✅ Accepted

	{ "email": "a@b.com", "role": "owner" }

❌ Rejected at runtime

Your app stays safe.

---

### 7. `z.enum()` vs TypeScript `enum` (Important)

TypeScript enum:

	enum Role {
	  USER = "user",
	  ADMIN = "admin",
	}

This:

- Exists only at compile time
- Does NOT validate runtime input
- Cannot protect APIs

Zod enum:

	const roleSchema = z.enum(["user", "admin"] as const);

This:

- Validates runtime input
- Produces a union type
- Is safe for APIs and external data

If needed, Zod also provides `z.nativeEnum()` for integrating with TS enums — but `z.enum()` is preferred for API boundaries.

---

### 8. Discriminator Fields (Preview)

	import { z } from "zod";

	const eventSchema = z.object({
	  type: z.enum(["LOGIN", "LOGOUT"] as const),
	  timestamp: z.number(),
	});

This pattern is commonly used later for **discriminated unions**, which Zod supports natively.

---

### 9. Common Mistakes (Avoid These)

#### ❌ Mistake 1 — Using `z.string()` for known values

	status: z.string(); // ❌ allows anything

Always restrict known values.

---

#### ❌ Mistake 2 — Using literals instead of enums

	z.literal("user").or(z.literal("admin")); // ❌ verbose

Better:

	z.enum(["user", "admin"] as const);

Cleaner, clearer, and idiomatic Zod.

---

#### ❌ Mistake 3 — Assuming enums are flexible

Enums are **closed sets**.

If valid values change, you must update the schema.  
This is intentional and prevents silent bugs.

---

### 10. Combining with `optional()` / `nullable()`

	import { z } from "zod";

	const schema = z.object({
	  role: z.enum(["user", "admin"] as const).optional(),
	});

Valid:

	{}
	{ role: "user" }

Invalid:

	{ role: "superadmin" }

Zod enforces correctness even when fields are optional.

---

### 11. Golden Rule (Memorize This)

If a field has **known valid values**, never use `z.string()`.

Use:

- `z.literal()` → **one exact value**
- `z.enum()` → **many allowed values**

---

### Final Takeaway

- `z.literal()` enforces one exact value
- `z.enum()` enforces a closed set of values
- Both validate at runtime and infer precise types
- This prevents silent production bugs
