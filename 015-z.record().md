## `z.record`

### Step 1 — The Problem: Dynamic Keys

Sometimes you **do not know object property names ahead of time**.

Common real-world examples:

- Feature flags
- Permissions
- Translation files (i18n)
- Settings keyed by ID
- Lookup tables

Example JSON:

	{
	  "featureA": true,
	  "featureB": false,
	  "experimentalX": true
	}

Here, the **keys are dynamic** and not predictable.

You **cannot safely model this** with:

	z.object({
	  featureA: z.boolean(),
	  featureB: z.boolean(),
	});

Because:
- Keys are not known in advance
- New keys may appear at any time
- Hardcoding keys causes schema drift

This is the exact problem `z.record()` exists to solve.

---

### Step 2 — What `z.record()` Means

	z.record(valueSchema)

This means:

> “An object with **any number of string keys**,  
> where **every value** must match `valueSchema`.”

Important points:

- Keys are **strings by default**
- Number of keys is **unbounded** unless restricted
- Every value is validated uniformly

Think of `z.record()` as:

	Record<string, ValueSchema>

At runtime **and** compile time.

---

### Step 3 — Basic Usage: Boolean Feature Flags

	const flagsSchema = z.record(z.boolean());

Valid:

	{
	  darkMode: true,
	  betaUser: false
	}

Invalid:

	{
	  darkMode: "yes"   // ❌ not boolean
	}

Why this works:

- Keys can be anything
- Values must always be boolean
- New flags do not require schema changes

---

### Step 4 — Validating BOTH Keys and Values

Zod can also validate **keys themselves**.

	const numericKeySchema = z.record(
	  z.string().regex(/^\d+$/),
	  z.string()
	);

Meaning:

- Keys must be **numeric strings**
- Values must be strings

Example valid object:

	{
	  "1001": "enabled",
	  "1002": "disabled"
	}

This form is:
- Less common
- Extremely powerful
- Useful for ID-keyed data

Note:
- Key schemas must still validate **strings**
- Validation is applied to `Object.keys()`

---

### Step 5 — Real-World Use Cases

#### A) Feature Flags

	const featureFlagsSchema = z.record(z.boolean());

Used when:
- Flags are added dynamically
- Feature names evolve over time

---

#### B) Permissions by Resource

	const permissionsSchema = z.record(
	  z.enum(["read", "write", "admin"])
	);

Example:

	{
	  "posts": "read",
	  "users": "admin"
	}

Ensures:
- Only valid permission values
- No unexpected strings

---

#### C) Translations (i18n)

	const translationsSchema = z.record(z.string());

Used for:
- Language dictionaries
- Key-value translation maps

---

#### D) Config Values (Mixed Types)

	const configSchema = z.record(
	  z.union([z.string(), z.number(), z.boolean()])
	);

Allows:
- Flexible config objects
- Strict value validation

---

### Step 6 — TypeScript Inference

	type FeatureFlags = z.infer<typeof featureFlagsSchema>;

Resulting type:

	Record<string, boolean>

This means:

- Any string key
- Boolean values only
- Fully type-safe and runtime-safe

No duplication. One source of truth.

---

### Step 7 — `z.record()` vs `z.object()`

| Use Case        | Use This              |
|-----------------|----------------------|
| Known keys      | `z.object()`         |
| Unknown keys    | `z.record()`         |
| Mixed           | `z.object().passthrough()` |

❌ Do **not** use `z.record()` when keys are fixed  
❌ Do **not** use `z.object()` when keys are dynamic

Choosing the wrong one leads to bugs or over-permissive schemas.

---

### Step 8 — Common Production Mistakes

#### ❌ Mistake 1 — Using `z.object({})` for Dynamic Keys

	z.object({}); // ❌ loses value validation

This accepts **any values of any type**.

---

#### ❌ Mistake 2 — Using `z.record(z.any())`

	z.record(z.any()); // ❌ useless

This throws away:
- Runtime safety
- Type safety
- All guarantees

---

#### ❌ Mistake 3 — Allowing Unbounded Objects

`z.record()` does **not** limit size by default.

If size matters:
- Enforce limits using `.refine()`
- Or validate `Object.keys(obj).length` explicitly

Example conceptually:

	limit number of entries
	prevent DoS-style payloads

---

### Golden Rule

- **If keys are unknown → use `z.record()`**
- **If keys are known → use `z.object()`**

This single rule prevents a huge class of schema bugs.
